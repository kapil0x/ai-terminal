#!/usr/bin/env node

/**
 * Semantic Search Demo for AI Terminal
 * 
 * This demonstrates how the CodeT5 embeddings-based semantic search works
 * to find code related to 'json parsing function' even without exact keyword matches.
 */

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

// Mock data representing what would be generated by CodeT5 embeddings
const mockEmbeddingsDatabase = [
  {
    filePath: './include/nlohmann/detail/input/parser.hpp',
    similarity: 0.92,
    metadata: {
      language: 'cpp',
      functions: ['parse', 'parse_value', 'parse_string', 'parse_object'],
      description: 'JSON parser implementation with comprehensive parsing logic'
    },
    codeSnippet: `// JSON parser implementation
class parser {
    json_value parse() {
        return parse_value();
    }
    
    json_value parse_value() {
        switch (current_token()) {
            case token_type::begin_object:
                return parse_object();
            case token_type::literal_string:
                return parse_string();
            // ... more parsing logic
        }
    }`
  },
  {
    filePath: './include/nlohmann/detail/input/json_sax.hpp',
    similarity: 0.88,
    metadata: {
      language: 'cpp',
      functions: ['sax_parse', 'parse_document', 'parse_array'],
      description: 'SAX-style JSON parsing interface for streaming data processing'
    },
    codeSnippet: `// SAX-style JSON parsing
template<typename JSONType>
class json_sax {
    bool parse_document() {
        return parse_value();
    }
    
    bool parse_array() {
        // Array parsing logic
        return true;
    }`
  },
  {
    filePath: './include/nlohmann/detail/conversions/from_json.hpp',
    similarity: 0.85,
    metadata: {
      language: 'cpp',
      functions: ['from_json', 'get_from_json', 'convert_from_json'],
      description: 'JSON to C++ object conversion functions'
    },
    codeSnippet: `// JSON conversion utilities
template<typename ValueType>
void from_json(const json& j, ValueType& val) {
    if (j.is_object()) {
        // Handle object conversion
    } else if (j.is_array()) {
        // Handle array conversion
    }
}`
  },
  {
    filePath: './include/nlohmann/json.hpp',
    similarity: 0.82,
    metadata: {
      language: 'cpp',
      functions: ['parse', 'dump', 'operator[]', 'at'],
      description: 'Main JSON class with parsing and serialization methods'
    },
    codeSnippet: `// Main JSON class
class basic_json {
    static basic_json parse(const string_type& s) {
        return parser(s).parse();
    }
    
    string_type dump() const {
        return serializer(*this).dump();
    }`
  },
  {
    filePath: './docs/mkdocs/docs/examples/parse__string.cpp',
    similarity: 0.78,
    metadata: {
      language: 'cpp',
      functions: ['parse_example', 'string_parsing_demo'],
      description: 'Example demonstrating string parsing functionality'
    },
    codeSnippet: `// String parsing example
#include <nlohmann/json.hpp>
using json = nlohmann::json;

int main() {
    std::string json_string = R"({"name": "John", "age": 30})";
    json j = json::parse(json_string);
    std::cout << j["name"] << std::endl;
}`
  },
  {
    filePath: './tests/src/unit-class_parser.cpp',
    similarity: 0.75,
    metadata: {
      language: 'cpp',
      functions: ['test_parser', 'test_parse_errors', 'benchmark_parsing'],
      description: 'Unit tests for JSON parser functionality and error handling'
    },
    codeSnippet: `// Parser unit tests
TEST_CASE("JSON parser tests") {
    SECTION("valid JSON parsing") {
        json j = json::parse(R"({"key": "value"})");
        REQUIRE(j["key"] == "value");
    }
    
    SECTION("invalid JSON handling") {
        REQUIRE_THROWS_AS(json::parse("{invalid}"), json::parse_error);
    }
}`
  }
];

function demonstrateSemanticSearch(query) {
  console.log(chalk.blue.bold('🔍 Semantic Search Demo: AI Terminal'));
  console.log(chalk.gray('Simulating CodeT5 embeddings-based search\n'));
  
  console.log(chalk.cyan(`Query: "${query}"`));
  console.log(chalk.gray('Finding semantically similar code patterns...\n'));
  
  // Simulate the embedding search process
  console.log(chalk.yellow('Step 1: Generating query embedding with CodeT5...'));
  console.log(chalk.gray('✓ Query vectorized to 768-dimensional embedding\n'));
  
  console.log(chalk.yellow('Step 2: Computing cosine similarity with codebase...'));
  console.log(chalk.gray('✓ Compared against 1,247 embedded code files\n'));
  
  console.log(chalk.yellow('Step 3: Ranking results by semantic similarity...\n'));
  
  console.log(chalk.blue.bold('📊 Results (ranked by semantic similarity):'));
  console.log(chalk.gray('Note: These results show semantic understanding beyond keyword matching\n'));
  
  mockEmbeddingsDatabase.forEach((result, index) => {
    console.log(chalk.yellow(`${index + 1}. ${result.filePath}`));
    console.log(chalk.gray(`   Similarity: ${(result.similarity * 100).toFixed(1)}%`));
    console.log(chalk.gray(`   Language: ${result.metadata.language}`));
    console.log(chalk.gray(`   Functions: ${result.metadata.functions.slice(0, 3).join(', ')}`));
    console.log(chalk.white(`   Description: ${result.metadata.description}`));
    console.log(chalk.gray('   Code Preview:'));
    console.log(chalk.dim(result.codeSnippet.split('\n').slice(0, 5).map(line => `     ${line}`).join('\n')));
    console.log();
  });
  
  console.log(chalk.green.bold('✨ Semantic Search Advantages:'));
  console.log(chalk.green('• Found JSON parsing code WITHOUT exact "json parsing function" keywords'));
  console.log(chalk.green('• Understands conceptual relationships (parse → conversion → serialization)'));
  console.log(chalk.green('• Ranks by semantic relevance, not just text matching'));
  console.log(chalk.green('• Discovered related functionality (SAX parsing, error handling, examples)'));
  console.log(chalk.green('• Works across different naming conventions and coding styles\n'));
  
  console.log(chalk.blue.bold('🆚 Comparison with Traditional Search:'));
  console.log(chalk.red('Traditional keyword search for "json parsing function":'));
  console.log(chalk.red('• Would miss files that use different terminology'));
  console.log(chalk.red('• No understanding of conceptual relationships'));
  console.log(chalk.red('• Limited to exact text matches'));
  console.log(chalk.red('• Poor ranking of relevance\n'));
  
  console.log(chalk.green('CodeT5 semantic search:'));
  console.log(chalk.green('• Understands that "parser", "from_json", "parse_value" are related'));
  console.log(chalk.green('• Finds conversion functions as semantically similar'));
  console.log(chalk.green('• Discovers test files and examples automatically'));
  console.log(chalk.green('• Provides confidence scores for relevance\n'));
  
  console.log(chalk.blue.bold('🚀 Next Steps to Try Live Search:'));
  console.log(chalk.cyan('1. Install dependencies: npm install'));
  console.log(chalk.cyan('2. Generate embeddings: node index.js embed-learn'));
  console.log(chalk.cyan('3. Run search: node index.js search "json parsing function"'));
  console.log(chalk.cyan('4. Compare with traditional grep/find results\n'));
  
  console.log(chalk.magenta.bold('💡 Use Cases:'));
  console.log(chalk.magenta('• "authentication logic" → finds auth, login, security code'));
  console.log(chalk.magenta('• "database queries" → finds SQL, ORM, data access patterns'));
  console.log(chalk.magenta('• "error handling" → finds exceptions, validation, logging'));
  console.log(chalk.magenta('• "string manipulation" → finds parsing, formatting, validation'));
}

// Run the demo
if (require.main === module) {
  demonstrateSemanticSearch('json parsing function');
}

module.exports = { demonstrateSemanticSearch };